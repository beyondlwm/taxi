# Copyright (C) 2018-present ichenq@outlook.com. All rights reserved.
# Distributed under the terms and conditions of the Apache License.
# See accompanying files LICENSE.

import codecs
import json
import os
import sys


def map_cpp_type(typ):
    type_mapping = {
        'bool': 'bool',
        'int8': 'int8_t',
        'uint8': 'uint8_t',
        'int16': 'int16_t',
        'uint16': 'uint16_t',
        'int': 'int',
        'int32': 'int32_t',
        'uint32': 'uint32_t',
        'int64': 'int64_t',
        'uint64': 'uint64_t',
        'float': 'float',
        'float32': 'float',
        'float64': 'double',
        'string': 'std::string',
    }
    return type_mapping[typ]

    
# 最长串的大小
def max_field_length(table, key, f):
    max_len = 0
    for v in table:
        n = len(v[key])
        if f is not None:
            n = len(f(v[key]))
        if n > max_len:
            max_len = n
    return max_len
    
    
# 空格对齐
def pad_spaces(text, min_len):
    if len(text) < min_len:
        for n in range(min_len - len(text)):
            text += ' '
    return text
    
    
# 生成Load方法
def gen_load_method(struct):
    content = 'func (p *%s) SelectStmt() string {\n' % struct['camel_case_name']
    content += '\treturn "SELECT '
    for i, field in enumerate(struct['fields']):
        content += '`%s`' % field['name']
        if i + 1 < len(struct['fields']):
            content += ', '
    content += ' FROM `%s`' % struct['name']

    primary_keys = get_key_list(struct['options'], 'primary_keys')
    if len(primary_keys) > 0:
        content += ' WHERE `%s`=?' % primary_keys[0]
    else:
        unique_keys = get_key_list(struct['options'], 'unique_keys')
        print('unique keys: ', unique_keys)
        if len(unique_keys) > 0:
            content += "WHERE "
            for i, key in enumerate(unique_keys):
                content += '`%s`=?' % key
                if i + 1 < len(unique_keys):
                    content += ' AND '
    content += '"\n}\n'
    return content
    
    
def gen_cpp_struct(struct):
    content = '// %s\n' % struct['comment']
    content += 'struct %s \n{\n' % struct['name']
    max_name_len = max_field_length(struct['fields'], 'name', None)
    max_type_len = max_field_length(struct['fields'], 'type_name', map_cpp_type)
    for field in struct['fields']:
        typename = map_cpp_type(field['type_name'])
        assert typename != "", field['type_name']
        typename = pad_spaces(typename, max_type_len+1)
        name = pad_spaces(field['name'], max_name_len+1)
        content += '    %s %s // %s\n' % (typename, name, field['comment'])
    
    return content

    
def get_struct_keys(struct):
    keys = struct['options']['keys'].split(',')
    assert len(keys) > 0, struct['name']
    key_tuples = []
    fields = struct['fields']
    for idx in keys:
        field = fields[int(idx)-1]
        typename = map_cpp_type(field['type_name'])
        name = field['name'].lower()
        key_tuples.append((typename, name))
    return key_tuples
    
    
def gen_static_method_declare(struct):
    keys = get_struct_keys(struct)
    args = []
    for tpl in keys:
        args.append(tpl[0] + ' ' + tpl[1])
    content = '    static std::vector<%s> Data;\n' % struct['name']
    content += '    static int Load();\n'
    content += '    static const %s* Get(%s);\n' % (struct['name'], ', '.join(args))
    return content

    
def gen_equal_stmt(prefix, struct):
    keys = get_struct_keys(struct)
    args = []
    for tpl in keys:
        args.append('%s.%s == %s' % (prefix, tpl[1], tpl[1]))
    return ' && '.join(args)

    
def gen_static_get_method(struct):
    keys = get_struct_keys(struct)
    args = []
    for tpl in keys:
        args.append('%s %s' %  (tpl[0], tpl[1]))
        
    content = 'const %s* %s::Get(%s)\n' % (struct['name'], struct['name'], ', '.join(args))
    content += '{\n'
    content += '    for (size_t i = 0; i < %s::Data.size(); i++)\n' % struct['name']
    content += '    {\n'
    content += '        if (%s)\n' % gen_equal_stmt('Data[i]', struct)
    content += '        {\n'
    content += '            return &Data[i];\n'
    content += '        }\n'
    content += '    }\n'
    content += '    return nullptr;\n'
    content += '}\n\n'
    return content
    
    
def gen_static_load_method(struct):
    content = 'int %s::Load()\n' % struct['name']
    content += '{\n'
    content += '    return 0;\n'
    content += '}\n\n'
    return content
    
    
    
def export_header_file(struct, params):
    content = '// This is file is auto-generated by taxi, DO NOT EDIT!\n\n#pragma once\n\n#include <stdint.h>\n#include <string>\n#include <vector>\n\n'
    content += gen_cpp_struct(struct)
    content += '\n'
    content += gen_static_method_declare(struct)
    content += '}\n\n'
    return content
    
    
def export_cpp_file(struct, params):
    content = '//This is file is auto-generated by taxi, DO NOT EDIT!\n\n#include "stdafx.h"\n#include <stddef.h>\n\n'
    content += 'std::vector<%s> %s::Data;\n\n' % (struct['name'], struct['name'])
    content += gen_static_get_method(struct)
    content += gen_static_load_method(struct)
    content += '\n'
    return content
    
    
# 执行导出
def run_export(info, params):
    descriptors = info['descriptors']
    header_content = ''
    cpp_content = ''
    for struct in descriptors:
        header_content += export_header_file(struct, params)
        cpp_content += export_cpp_file(struct, params)
    
    filename = 'AutogenConfig.h' #params['output-file']
    f = codecs.open(filename, 'w', 'gbk')
    f.writelines(header_content)
    f.close()
    print('wrote to %s' % filename)
    
    filename = 'AutogenConfig.cpp'
    f = codecs.open(filename, 'w', 'gbk')
    f.writelines(cpp_content)
    f.close()
    print('wrote to %s' % filename)    
    
def main():
    params = {}
    print(sys.argv)
    if len(sys.argv) < 2:
        print('no arguments specified')
        sys.exit(1)

    if len(sys.argv) >= 3:
        if len(sys.argv[2]) > 0:
            kvlist = sys.argv[2].split(',')
            for item in kvlist:
                kv = item.split('=')
                assert len(kv) == 2, item
                params[kv[0]] = kv[1]

    info = json.loads(sys.argv[1])
    f = codecs.open(info['filepath'], 'r', 'utf8')
    obj = json.loads(f.read())
    f.close()
    run_export(obj, params)


if __name__ == '__main__':
    main()
    
